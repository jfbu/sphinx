\ProvidesPackage{sphinxbreakablebox}[2023/03/17 v6.2.0 breakable variant of
                                     \detokenize{\sphinxbox}
                                     (fragile, not really tested, use at own risk)]
% This Work may be distributed and/or modified under the
% conditions of the LaTeX Project Public License, in its
% version 1.3c.  This version of this license is in
% > <http://www.latex-project.org/lppl/lppl-1-3c.txt>
% and the latest version of this license is in
% > <http://www.latex-project.org/lppl.txt>
% and version 1.3 or later is part of all distributions of
% LaTeX version 2005/12/01 or later.
% The Author of this Work is Jean-Francois B. (jfbu)
% This Work consists of this file sphinxbreakablebox.sty
% Its current version is to be found at
% https://github.com/jfbu/sphinx/tree/wip_breakable_sphinxbox
% as file sphinx/texinputs/sphinxbreakablebox.sty
% It builds upon tools developed as part of the LaTeX maintenance
% of the Sphinx project currently hosted at
% https://github.com/sphinx-doc/sphinx

% Breakable horizontal boxes are a difficult topic in LaTeX.  For related
% discussion which motivated this see the comments at
% https://github.com/sphinx-doc/sphinx/pull/11224

% Notice that any solution based on soul/soulutf8 package will have probably
% strong limitations.  Soul package tries to dissect the input into syllables
% and later reconstruct it and this is very fragile.  Soul has long list of
% built-in mark-up from TeX/LaTeX which its author hard-coded as known tokens,
% and it knows nothing about Sphinx.  Perhaps your best bet is to use LuaLaTeX
% engine and the lua-hl package:
%     https://ctan.org/pkg/lua-ul
%
% Then use preamble redefinition of \sphinxguilable for example, as above, but
% using the commands of lua-ul.

% Reasons for not merging this in Sphinx:
% - the whole idea of boxing individually each character means kerning
%   and ligatures and hyphenation points are all lost
% - PDF viewers have issues with next to next boxes of same color,
%   even overlapping a bit did not help get rid of aliasing (?) artifacts.
% - the code is quite complex and achieves some rather surprising things,
%   but is very easily broken by unexpected input (in theory not by
%   input from Sphinx mark-up, but no complete examination was done).

% Instructions:
% You must be using Sphinx version at least 6.2.0.
% 1) Add this file to your project.  Or work from an editable pip
%    install of Sphinx on the branch where the wip_breakable_sphinxbox
%    of my fork has been merged and then you skip step 2) and should
%    go to step 3) directly.  Merging is conflict free as it simply
%    adds this file, but touches nothing else of Sphinx LaTeX.
% 2) * Add to conf.py
%         latex_additional_files = ["sphinxbreakablebox.sty"]
%      (or with the actual path to where you moved sphinxbreakablebox.sty)
%    * An alternative is to add sphinxbreakablebox.sty to your LaTeX
%      installation, e.g. in your texmf-local directory (assuming TeXLive)
%      or in some "$HOME/.texmf" or "$HOME/Library/texmf" (mac os)
%      for example as
%        <texmf>/tex/latex/sphinxbreakablebox/sphinxbreakablebox.sty
%      so that the file can be seen by LaTeX from any project.
% 3) Extend latex_elements['preamble'] in conf.py like this:
%     latex_elements = {
%         'preamble': r"""
%     \usepackage{sphinxbreakablebox}
%     % Then add definitions using \sphinxbreakablebox.
%     % See
%     % https://www.sphinx-doc.org/en/master/latex.html#macros
%     % for candidates to redefine.  Here is one:
%     \protected\def\sphinxguilabel#1{%
%         \sphinxbreakablebox[% put extra options here as per \sphinxbox doc
%                             % the options of \sphinxbox at time of use will be
%                             % automatically inherited
%                            ]{#1}}
%     """,
%     }

% Use at own risk: this is fragile untested and surely unmaintained code.
% Its sole advantage is to build upon existing work done at Sphinx for
% low-weight support of rounded boxes.

% The latest iteration has tried to provide support for "nesting" situations
% arising from definitions like those:
% 
% \protected\def\sphinxstyleliteralstrong#1{%
%     \sphinxbreakablebox[options]{\emph{\sphinxcode{#1}}}}
% \protected\def\sphinxcode#1{\sphinxbreakablebox[options]{#1}}
%
% But it is impossible for the external box to know in advance what would be
% the height+depth of contents as as to equalize them.  If as in the above we
% have only one nesting, then one could imagine truly emulate the insertion of
% one box in the other, but if I have to support nested input possibly
% containing other tokens not in the nested box, there is no other way to keep
% equal heights, than to decide that it is the inner box, and only it, which
% does the drawing.  This is what the current code achieves, and it has quite
% complex parts due to TeXnicalities.  I tested it with three level of
% nestings... now the alternative, much much simpler than current code, could
% have been for only the external boxing to be kept.  I chose the opposite and
% as it took me some effort I am leaving it like this.
%
% The second thing to keep in mind, is that the inner box will be imprinted
% by all options of the outer box that it does not override.
%
% If the inner box has big padding and there is something else in the external
% box, the heights will be uneven.  So nesting is supported to the extent of
% (hopefully) not causing a build crash, not to the extend of nice looks.

% With the latest code iteration an empty input means that nothing at all will
% be drawn, only effect will be to start a paragraph from \leavevmode.

% \RequirePackage{sphinx}% if instructions above are followed not needed.
% This file can not be used independently from sphinx.

% To avoid potential clashes with future Sphinx, macros are defined
% with \spx@jfbu@breakable@ prefix

% User can \renewcommand these:
\def\sphinxbreakableboxcontinuationhint{%
    \llap{\textcolor{gray}{$\m@th\hookrightarrow$ }}%
}
\def\sphinxbreakableboxinterboxsep{%
  % This next line was added when testing with very long contents filling up a
  % line, and helped avoid some Underfull hbox complaints of TeX.  Maybe it is
  % not a good idea in general as usually TeX will find suitable stretch shrink
  % on the line as the breakable box will not have a length exceeding a
  % linewidth.  I ended up commenting it out, which also avoids having to add a
  % macro to hold the 0.1pt to make it easily customizable.
  %
  % \nobreak\hskip0pt plus 0pt minus 0.1pt\relax
  %
  \discretionary{}{\copy\sphinxcontinuationbox}{}%
}
% MEMO: \sphinxcontinuationbox is a box register from sphinxlatexliterals.sty
% which we can use.  It will be initialized at time of use by
% \sphinxbreakablebox to contain expansion of \sphinxbreakableboxcontinuationhint.

% These utilities will have to be used in a scope limiting context, else I
% would have to add some macro to store and restore a given configuration
% or radii, paddings and border widths.
\def\spx@jfbu@breakable@openright{%
    \spx@boxes@border@right      \z@
    \spx@boxes@padding@right     \z@
    \spx@boxes@radius@topright   \z@
    \spx@boxes@radius@bottomright\z@
    % An external shadow if on right works fine; does not work if on left.
    %
    % An inset shadow is supported only by rectangular boxes.
    % We only need to cancel the x-shift for the intermediate ones.
    \ifspx@boxes@withshadow
        \ifspx@boxes@insetshadow
           \ifdim\spx@boxes@shadow@xoffset<\z@
                 \spx@boxes@shadow@xoffset=\z@
           \fi
        \fi
    \fi
    \spx@boxes@fcolorbox@setup@fcolorbox
}%
\def\spx@jfbu@breakable@openleft{%
    \spx@boxes@border@left      \z@
    \spx@boxes@padding@left     \z@
    \spx@boxes@radius@topleft   \z@
    \spx@boxes@radius@bottomleft\z@
    \ifspx@boxes@withshadow
        \ifspx@boxes@insetshadow
           \ifdim\spx@boxes@shadow@xoffset>\z@
                 \spx@boxes@shadow@xoffset=\z@
           \fi
        \fi
    \fi
    \spx@boxes@fcolorbox@setup@fcolorbox
}%
\def\spx@jfbu@breakable@openboth{%
    \spx@boxes@border@left       \z@
    \spx@boxes@border@right      \z@
    \spx@boxes@padding@left      \z@
    \spx@boxes@padding@right     \z@
    \spx@boxes@radius@topright   \z@
    \spx@boxes@radius@bottomright\z@
    \spx@boxes@radius@topleft    \z@
    \spx@boxes@radius@bottomleft \z@
    \ifspx@boxes@withshadow
        \ifspx@boxes@insetshadow
            \spx@boxes@shadow@xoffset\z@
        \fi
    \fi
    \def\spx@boxes@fcolorbox{\spx@boxes@fcolorbox@rectangle}%
}%

\catcode`Z=3 % safe delimiter
% Note that \sphinxbreakablebox fetches its second input argument so no \verb is
% allowed there in #2.  But Sphinx mark-up needing catcode changes uses \scantokens
% anyhow.  #2 can be empty without breaking the macro.  It can also be a single
% character.  It can even be a nested use of \sphinxbreakablebox!

% The parser identifies some type of inputs (such as the Sphinx TeX escapes of
% special characters, or active characters inclusive of those for pdflatex
% support of utf-8).  But basically, all macros not known explicitly will be
% assumed to be one-argument macros which only change some font properties and
% do not induce any typesetting of their own, even spaces.  This is handled in
% the "crazystuff" part, which is really crazy.
\newcommand\sphinxbreakablebox[2][]{%
  % #1 stands for the options, they are... optional!
  % external shadow is ok if on right; not supported on left
  % inset shadow is ok but only for rectangular boxes
  \leavevmode
  \begingroup
    \let\spxnameuse\@nameuse
    \sbox\sphinxcontinuationbox {\sphinxbreakableboxcontinuationhint}%
    \sphinxboxsetup{#1}%
    \spx@boxes@fcolorbox@setup
        {box}
        {sphinxboxBorderColor}
        {sphinxboxBgColor}
        {sphinxboxShadowColor}%
    \ifx\spx@jfbu@breakable@setboxtype\@empty
       % not nested
       \gdef\spx@jfbu@breakable@setboxtype{\spx@jfbu@breakable@startbox}%
    \fi    
    \spx@jfbu@breakable@a #2Z%
    \endgroup
    \global\let\spx@jfbu@breakable@setboxtype\@empty
}

\let\spx@jfbu@breakable@setboxtype\@empty
\def\spx@jfbu@breakable@startbox{%
  \spx@jfbu@breakable@openright % <-- must be executed in a scope limiting group
  % Using some \let as an \ifx test is done in \spx@jfbu@breakable@check.
  \global\let\spx@jfbu@breakable@setboxtype\spx@jfbu@breakable@openboth
}%
% final boxing may be of two kinds:
\def\spx@jfbu@breakable@finalbox{%
  % shadow on right is counted in the box width (and will not
  % protrude in margin if we are quite at end of line).
  \spx@boxes@shadowinbboxtrue
  \spx@jfbu@breakable@openleft
}
% this one is used when the input was a single "character" (or empty).
\def\spx@jfbu@breakable@onecharbox{\spx@boxes@shadowinbboxtrue}

% start of main loop; it will also be used in subroutines which are
% fed to macros supposed to only change font proportiers and at any
% rate do only non-typesetting things; if they for example create
% some horizontal space, this space will not be boxed.
\def\spx@jfbu@breakable@a{\futurelet\spx@nexttoken\spx@jfbu@breakable@b}
\def\spx@jfbu@breakable@b{%
    \ifx\spx@nexttoken Z%
      \def\next{\spx@jfbu@breakable@done}%
    \else
    \ifcat\noexpand\spx@nexttoken\relax
      \def\next{\spx@jfbu@breakable@casei}%
      % as this is the most annoying branch its code is given last below
    \else
    \ifx\spx@nexttoken\bgroup
      % naked braced material, should never happen in Sphinx I think
      % we will handle this by removing the brace pair and start again
      \def\next{\spx@jfbu@breakable@caseii}%
    \else
    \ifx\spx@nexttoken\@sptoken
      % a space, so it was following some character or {} and
      % we will handle this basically as we handle a single character
      \def\next{\spx@jfbu@breakable@caseiii}%
    \else
      % hopefully some character token
      \def\next{\spx@jfbu@breakable@mainloop}%
    \fi\fi\fi\fi
    \next
}%
%
% some braced material; impossible in Sphinx a priori.  Unbrace and proceed.
% This is catastrophic if e.g. input is {\Large foo}.   Although I think no such
% mark-up comes from Sphinx, expanding for example \sphinxoptional would
% create it (see below discussion of \sphinxoptional).
\def\spx@jfbu@breakable@caseii#1{\spx@jfbu@breakable@a #1}
% handle the blank space
\@firstofone{\def\spx@jfbu@breakable@caseiii} {\spx@jfbu@breakable@mainloop{ }}
% the simple case
\def\spx@jfbu@breakable@mainloop #1{%
    % need to check if at end; and add a strut to equalize heights
    % \strut first in case of size changing command in #1, we don't
    % want this \strut to be affected.  But likely if you suddenly
    % use some large font in the midst of it, the box pieces will not
    % have matching heights and depths.
    \def\spx@temp{{\strut#1}}%
    \futurelet\spx@nexttoken\spx@jfbu@breakable@check
}
\def\spx@jfbu@breakable@check{%
    \def\next{\spx@jfbu@breakable@again}%
    \ifx\spx@nexttoken Z%
       \def\next{\spx@jfbu@breakable@done}%
       % We fetched the last "character"; but perhaps we are reaching the end
       % of a sub-routine triggered by crazy branch so we can't be sure what
       % to do, but the crazy branch knows if we are really at end hence
       % made appropriate configuration of @finalbox and @onecharbox
       \ifx\spx@jfbu@breakable@setboxtype\spx@jfbu@breakable@openboth
         % This is at least the second handled "character"
         \global\let\spx@jfbu@breakable@setboxtype\spx@jfbu@breakable@finalbox
       \else
         % This was a single "character" box
         \global\let\spx@jfbu@breakable@setboxtype\spx@jfbu@breakable@onecharbox
       \fi
    \fi
    {% scope when expanding @openright or @openboth or @openleft
     % must be limited hence this brace group (see above remarks)
     \spx@jfbu@breakable@setboxtype
     \expandafter\spx@boxes@fcolorbox\spx@temp
    }%
    \next
}
\def\spx@jfbu@breakable@again{%
    \sphinxbreakableboxinterboxsep % customizable by user
    \futurelet\spx@nexttoken\spx@jfbu@breakable@b
}
\def\spx@jfbu@breakable@done Z{}

% The more complex branch.  Let's filter out special tokens coming out from
% the TeX escape done by sphinx.util.texescape; also we will catch \( which is
% used for some such TeX escapes.  Other escapes are control sequences
% followed by a {}, those are caught further down in the crazy stuff.
\def\spx@jfbu@breakable@casei #1{%
    \in@{#1}{\$\%\&\#\_\{\}}%
    \ifin@
      \def\next{\spx@jfbu@breakable@mainloop}%
    \else
      \ifx#1\(%
        \def\next{\spx@jfbu@breakable@casei@ltxmath}%
      \else
        \def\next{\spx@jfbu@breakable@casei@a}%
      \fi
    \fi \next #1%
}%
% Assume this was really \( token which comes from sphinx.util.texescape hence
% is matched.
\def\spx@jfbu@breakable@casei@ltxmath\(#1\){\spx@jfbu@breakable@mainloop{\(#1\)}}

% Test for some active character
\def\spx@jfbu@breakable@casei@a #1{%
    \ifcat\noexpand~\noexpand#1\relax% active character
       \expandafter\spx@jfbu@breakable@casei@active
    \else % some control sequence
      \expandafter\spx@jfbu@breakable@casei@b
    \fi #1%
}%
% Try to distinguish genuine active characters from LaTeX's UTF-8 encoding
% support in (pdf)latex.  I don't have time for rekindling my knowledge here,
% simply check if we are handling a byte of code <128.  Active characters may
% come from babel shorthands, e.g. in French !?:; which add extra spacing:
% this will work in the box as well (but as each character token ends up being
% handled individually the extra space will be there even after a space in
% source).  Inline literals add a \sphinxupquote wrapper which redefines
% active . , ; ? ! / so in such case as testing confirmed, if one is crazy
% enough to let \sphinxcode use a \sphinxbreakablebox, only the : will add
% extra space to its left.
\def\spx@jfbu@breakable@casei@active#1{%
    \ifnum`#1<128
      \expandafter\spx@jfbu@breakable@mainloop
    \else % assume UTF-8...
      \expandafter\spx@jfbu@breakable@casei@active@a
    \fi #1%
}%
\def\spx@jfbu@breakable@casei@active@a #1{%
    \expandafter\spx@jfbu@breakable@casei@active@b#1{}{}{}{}{}{}{}{}{}{}Z#1%
}%
% I use \def's not \let's only for easier debugging via log trace if needed.
% But no debugging was needed: the method is more or less copied from
% my existing code in sphinxlatexliterals.sty.
\def\spx@jfbu@breakable@casei@active@b #1#2Z{%
    \ifx\UTFviii@four@octets#1\def\next{\spx@jfbu@breakable@four}\else
    \ifx\UTFviii@three@octet#1\def\next{\spx@jfbu@breakable@three}\else
    \ifx\UTFviii@two@octets #1\def\next{\spx@jfbu@breakable@two}\else
    \def\next{\spx@jfbu@breakable@mainloop}%
    \fi\fi\fi
    \next
}%
\def\spx@jfbu@breakable@two   #1#2{\spx@jfbu@breakable@mainloop{#1#2}}%
\def\spx@jfbu@breakable@three #1#2#3{\spx@jfbu@breakable@mainloop{#1#2#3}}%
\def\spx@jfbu@breakable@four  #1#2#3#4{\spx@jfbu@breakable@mainloop{#1#2#3#4}}%

% Intercept some special macros... the list should surely be much longer.  In
% particular \sphinxupquote will be handled as the common lot in the
% "crazystuff", which is very adventurous but worked in brief testing.
% Although it did ultimately cause very serious complications in the
% "crazystuff".
\let\sphinxbreakableboxspecialcommands\empty % for user customization
% but one then must produce a custom associated macro... which is basically
% possible only by package author or copying the code with some luck.
\def\spx@jfbu@breakable@casei@b #1{%
    \def\spx@temp{\in@{#1}}%
    \expandafter\spx@temp\expandafter{%
      \sphinxbreakableboxspecialcommands
      \sphinxhref\sphinxoptional\sphinxbreakablebox\sphinxbox\spxnameuse
    }%
    \ifin@
        % of course assume standard \escapechar
        \csname spx@jfbu@breakable@special@\expandafter
                \@gobble\string#1\expandafter\endcsname
    \else
      \expandafter\spx@jfbu@breakable@casei@c
    \fi #1%
}%
% one very very special special; mind-boggling nesting abilities... (although
% the output is lame, but the fact that it all works is quite subtle).
\def\spx@jfbu@breakable@special@spxnameuse\spxnameuse#1{%
     \spxnameuse{#1}\spx@jfbu@breakable@a
}
% \sphinxhref has two arguments.  But can a \sphinxhref arise nested from
% Sphinx mark-up? I had to test it manually; TODO: check if I can create an
% index.rst causing a nested \sphinxref in mark-up for roles such as guilabel
% etc..
\def\spx@jfbu@breakable@special@sphinxhref\sphinxhref#1#2{%
    % It is rather **incredible** that this works, the \sphinxhref will be applied
    % with its second argument replaced by a nested use of \sphinxbreakablebox
    % or rather its subcore loop starting with \spx@jfbu@breakable@a
    % Hair-rising when one knows the \everyeof/\scantokens business of \sphinxhref.
    \def\spx@tempa{\sphinxhref{#1}}%
    \def\spx@tempb{#2}%
    \futurelet\spx@nexttoken\spx@jfbu@breakable@casei@crazystuff
}
% The default sphinxoptional does
% \textnormal{\Large[}}{#1}\hspace{0.5mm}{\textnormal{\Large]}}
% The \Large and \hspace are annoying to us, we need here to take a branch
% very different from the crazy \spx@jfbu@breakable@casei@crazystuff below
% let's simply gather the macro and its argument and treat it as one
% unbreakable unit.
% \Large[ is bigger than the reserved space for \strut.
% Oh well, I don't want to spend ages on this, so:
\def\spx@jfbu@breakable@special@sphinxoptional\sphinxoptional#1{%
    % awful and conditioned to \sphinxoptional not having been redefined
    % and treaated as one unit, no breaking
    \spx@jfbu@breakable@mainloop{{\let\Large\empty\sphinxoptional{#1}}}%
}%
% MEMO: The next macro is a priori useless in Sphinx context, because although
% the user can configure the text styling to cause a nested \sphinxbreakablebox
% the mark-up itself will create this only from expansion, but our parser
% attempts no expansion.  So this is mainly for manual usage of this
% package by manual mark-up.  Nesting from user conf.py is supported below
% in another manner via the "crazystuff", which goes in pair with the "nameuse"
% business above.
%
% A nested \sphinxbreakablebox will take over.  But its ending must
% still use openboth.  The special check for empty input which I added
% to core loop will make the external recover and add some suitable empty
% end.  As I will let \sphinxbox act here like \sphinxbreakablebox,
% I leave a generic #1.  We need to gather options to if there.
\def\spx@jfbu@breakable@special@sphinxbreakablebox #1{%
  \begingroup
    % if we are at start draw an opening empty cell
    \ifx\spx@jfbu@breakable@setboxtype\spx@jfbu@breakable@openboth
    \else
      {\spx@jfbu@breakable@openright
       \spx@boxes@fcolorbox{\strut}%
      }%
      % do not allow line break here (as it will not be allowed before
      % if we are at end, before the last empty closing box)
    \fi
    \global\let\spx@jfbu@breakable@setboxtype\spx@jfbu@breakable@openboth
    \let\spx@jfbu@breakable@finalbox\spx@jfbu@breakable@openboth
    % We must first gather options if present.
    % Using #{ would be dangerous if options use some brace pair.
    \futurelet\spx@nexttoken
    \spx@jfbu@breakable@breakablebox@i
}
\let\spx@jfbu@breakable@special@sphinxbox\spx@jfbu@breakable@special@sphinxbreakablebox
\def\spx@jfbu@breakable@breakablebox@i{%
    \ifx\spx@nexttoken[%
      \expandafter\spx@jfbu@breakable@breakablebox@A
    \else
      \expandafter\spx@jfbu@breakable@breakablebox@B
    \fi
}
\def\spx@jfbu@breakable@breakablebox@A[#1]#2{%
    \def\spx@temp{\sphinxbreakablebox[{#1}]{#2}}%
    \futurelet\spx@nexttoken\spx@jfbu@breakable@breakablebox@j
}
\def\spx@jfbu@breakable@breakablebox@B#1{%
    \def\spx@temp{\sphinxbreakablebox{#1}}%
    \futurelet\spx@nexttoken\spx@jfbu@breakable@breakablebox@j
}
\def\spx@jfbu@breakable@breakablebox@j{%
    \let\spx@jfbu@breakable@finalbox\spx@jfbu@breakable@openboth
    \let\spx@jfbu@breakable@onecharbox\spx@jfbu@breakable@openboth
    \ifx\spx@nexttoken Z%
      \def\next
      {\spx@temp
       \spx@jfbu@breakable@openleft
       % no line breaking allowed here
       \spx@boxes@fcolorbox{\strut}%
       \endgroup
       \spx@jfbu@breakable@done
       }%
    \else
      \def\next{\spx@temp\endgroup\spx@jfbu@breakable@again}%
    \fi
  \next
}%
\def\spx@jfbu@breakable@casei@c #1#2{%
    % **assume** #1 is now either
    % - a **one-argument** macro, doing only some font-switching, and
    %   no insertion of extras, typically \textbf.
    % - or perhaps some escape of a special character which Sphinx outputs
    %   as  \controlsequence{}, e.g. \sphinxhyphen{}.
    % - or... I have made this work with #1 itself calling 
    %   a sub \sphinxbreakablebox...
    \def\spx@tempa{#1}%
    \def\spx@tempb{#2}%
    % then dispatch to crazy nested usage of the whole thing!
    \futurelet\spx@nexttoken\spx@jfbu@breakable@casei@crazystuff
}
% Some completely crazy method here
\def\spx@jfbu@breakable@casei@crazystuff{%
    \ifx\spx@nexttoken Z%
      % nothing more to do and the appropriate closing box drawn
      \def\next{\spx@jfbu@breakable@done}%
    \else
      \def\next{\spx@jfbu@breakable@again}%
    \fi
    \if\relax\detokenize\expandafter{\spx@tempb}\relax
       % Seems #1 is some latex escape of a special character, as it was
       % followed by {}.  Attention that \sphinxhyphen is defined to gobble the
       % {}, so at least to handle this case right, we insert the {} again.
       % Also attention that some other \foo {} mark-up may arise from
       % Sphinx such as \item {} but it seems unlikely in this context.
       \def\spx@temp{{\strut\spx@tempa{}}}%
       % Plug into the check for being at end, with prepared \spx@temp.
       \def\next{\spx@jfbu@breakable@check}%
    \else
       % #1 (i.e. now the contents of \spx@tempa)
       % was some macro with a non-empty argument, try something crazy.
       % I made the code robust against some stuff such as {{{}}}
       % as \spx@jfbu@breakable@b now guards against such thing.
       % Important:
       % - Utter breakage if #1 is a multiple-argument macro
       % - Should work if #1 is some \textit for example.  Hopefully.
       % - The command #1 should not do any insertion of characters, or spaces,
       %   as those will not be boxed... so in fact the allowed things
       %   are a short list and I should have rather filtered them out
       %   especially, rather than ending here generically.  Very bad.
       {%
         \ifx\spx@nexttoken Z%
           % this was last "character" so allow subroutine to do the
           % appropriate closing via openleft or no open at at all
           % (e.g. \sphinxbreakablebox{\texttt{foo}} case)
         \else
           % not last. The @finalbox will be executed at end of sub-stuff if
           % there was at least two chars in the sub-stuff here, or if we
           % already are in openboth status
           \let\spx@jfbu@breakable@finalbox\spx@jfbu@breakable@openboth
           % the onecharbox will only be executed if we are executing
           % this at very start of the \sphinxbreakablebox input
           \def\spx@jfbu@breakable@onecharbox{\spx@jfbu@breakable@startbox}%
         \fi
         % \scantokens from \sphinxupquote is a real problem.  I almost
         % decided to do \let\sphinxupquote\@firstofone in this environment.
         % It is complex to work around a potential \scantokens destroying
         % the funny Z, and encapsulation in a macro quickly will cause
         % the macro to be redefined in terms of itself in case of nesting.
         % Hence this devilish code.
         \edef\spx@jfbu@breakable@nestinglevel{\the\numexpr
              \spx@jfbu@breakable@nestinglevel+1}%
         \expandafter\def\csname spx@jfbu@breakable@storage%
                                 \spx@jfbu@breakable@nestinglevel
         \expandafter\endcsname\expandafter{\expandafter\begingroup
               \expandafter\spx@jfbu@breakable@a\spx@tempb Z\endgroup}%
         \edef\next{\noexpand\spx@tempa{\noexpand
                \spxnameuse{spx@jfbu@breakable@storage\spx@jfbu@breakable@nestinglevel}}}%
         \next % (gets restored on exit of this group)
       }%
       \global\let\spx@jfbu@breakable@setboxtype\spx@jfbu@breakable@openboth
    \fi
    \next
}
\def\spx@jfbu@breakable@nestinglevel{0}%
\catcode`Z 11 % normal letter catcode

\endinput
